#include <iostream>
#include <fstream>
#include <vector>
#include <regex>

#include <cppast/cpp_entity_kind.hpp>
#include <cppast/cpp_forward_declarable.hpp>
#include <cppast/cpp_namespace.hpp>
#include <cppast/libclang_parser.hpp>
#include <cppast/visitor.hpp>
#include <cppast/cpp_function.hpp>
#include <cppast/cpp_type_alias.hpp>
#include <cppast/cpp_member_function.hpp>
#include <cppast/cpp_member_variable.hpp>
#include <cppast/cpp_enum.hpp>
#include <cppast/cpp_type.hpp>

using namespace std;
using namespace cppast;

// TODO
// Klassen auslagern
// -> import/export
// optionale Parameter
// converter aus Conversion Constructor
// Constructor bei deleted = ??
// typedefs merken und substituten
// STL Typen wrappen

vector<string> reserved_keywords {
  "addr",
  "and",
  "as",
  "asm",
  "bind",
  "block",
  "break",
  "case",
  "cast",
  "concept",
  "const",
  "continue",
  "converter",
  "defer",
  "discard",
  "distinct",
  "div",
  "do",
  "elif",
  "else",
  "end",
  "enum",
  "except",
  "export",
  "finally",
  "for",
  "from",
  "func",
  "if",
  "import",
  "in",
  "include",
  "interface",
  "is",
  "isnot",
  "iterator",
  "let",
  "macro",
  "method",
  "mixin",
  "mod",
  "nil",
  "not",
  "notin",
  "object",
  "of",
  "or",
  "out",
  "proc",
  "ptr",
  "raise",
  "ref",
  "return",
  "shl",
  "shr",
  "static",
  "template",
  "try",
  "pair",
  "type",
  "using",
  "var",
  "when",
  "while",
  "xor",
  "yield"
};

string cToNimType(const cpp_type& t, bool removeNamespace = true)
{
  const cpp_type* type = &t;
  bool pointer = false;

  if (type->kind() == cpp_type_kind::pointer_t)
  {
    auto& p = static_cast<const cpp_pointer_type&>(*type);
    type = &p.pointee();
    pointer = true;
  }
  if (type->kind() == cpp_type_kind::reference_t)
  {
    auto& r = static_cast<const cpp_reference_type&>(*type);
    type = &r.referee();
  }
  if (type->kind() == cpp_type_kind::cv_qualified_t)
  {
    auto& c = static_cast<const cpp_cv_qualified_type&>(*type);
    type = &cppast::remove_cv(*type);
  }
  if (type->kind() == cpp_type_kind::builtin_t)
  {
    auto& b = static_cast<const cpp_builtin_type&>(*type);
    switch (b.builtin_type_kind())
    {
      case cpp_builtin_type_kind::cpp_long:
        return "clong";
        break;
      case cpp_builtin_type_kind::cpp_ulong:
        return "culong";
        break;
      case cpp_builtin_type_kind::cpp_char:
        return "cchar";
        break;
      case cpp_builtin_type_kind::cpp_schar:
        return "cschar";
        break;
      case cpp_builtin_type_kind::cpp_short:
        return "cshort";
        break;
      case cpp_builtin_type_kind::cpp_int:
        return "cint";
        break;
      case cpp_builtin_type_kind::cpp_longlong:
        return "clonglong";
        break;
      case cpp_builtin_type_kind::cpp_float:
        return "cfloat";
        break;
      case cpp_builtin_type_kind::cpp_double:
        return "cdouble";
        break;
      case cpp_builtin_type_kind::cpp_longdouble:
        return "clongdouble";
        break;
      case cpp_builtin_type_kind::cpp_uchar:
        return "cuchar";
        break;
      case cpp_builtin_type_kind::cpp_ushort:
        return "cushort";
        break;
      case cpp_builtin_type_kind::cpp_uint:
        return "cuint";
        break;
      case cpp_builtin_type_kind::cpp_ulonglong:
        return "culonglong";
        break;
      case cpp_builtin_type_kind::cpp_void:
        return "void";
        break;
      case cpp_builtin_type_kind::cpp_bool:
        return "bool";
        break;
      default:
        break;
    }
  }
  string result = to_string(*type);
  if (result.find("::") != string::npos && removeNamespace)
    result = result.substr(result.find_last_of("::") + 1);
  if (pointer)
    result = "ptr " + result;
  return result;
}

string escapeIdentifier(string name)
{

  string entityName = name;
  for (string s: reserved_keywords)
  {
    if (s == entityName)
      return "`" + entityName + "`";

  }
  if (entityName.find("operator") != string::npos)
  {
    return "`" + entityName.replace(entityName.find("operator"), 8, "") + "`";
  }
  return name;
}

bool knownType(const cpp_type& type)
{
  return type.kind() == cpp_type_kind::builtin_t;
}

struct s_variable
{
  string name;
  const cpp_type *type;
};

struct s_enum_value
{
  string name, value;
  bool has_value;
};

struct s_function
{
  string name;
  vector<s_variable> params;
  const cpp_type *return_type;
  bool constructor = false;
};

struct s_class
{
  string name, base, scope;
  vector<s_variable> vars;
  vector<s_function> funs;
};

struct s_enum
{
  string name;
  vector<s_enum_value> vals;
};

struct s_typedef
{
  string name;
  const cpp_type *ref;
};


vector<string> cpp_files;

map<string, s_class> classes;
map<string, s_enum> enums;
map<string, s_typedef> typedefs;
vector<s_function> functions;

void print_classes(ostream& out, string& file)
{
  if (classes.empty())
    return;
  out << "#\n# Classes\n#\n\n";
  for (auto& c: classes)
  {
    out
      << "type\n"
      << "  "
      << c.second.name
      << "* {.importcpp: \""
      << c.second.scope + c.second.name
      << "\", header: \""
      << file
      << "\".} = object"
      << endl;
    for (auto& v: c.second.vars)
    {
      out
        << "    "
        << escapeIdentifier(v.name)
        << "*: "
        << cToNimType(*v.type)
        << "\n";
    }
    out << endl;
    for (auto& m: c.second.funs)
    {
      bool put_comma = true;
      if (m.constructor)
      {
        out
          << "proc new"
          << c.second.name
          << "*(";
        put_comma = false;
      }
      else
      {
      out
        << "method "
        << m.name
        << "* (this: "
        << c.second.name;
      }

      for (auto& p: m.params)
      {
        if (put_comma)
        {
          out << ", ";
        }
        else
        {
          put_comma = true;
        }

        out
          << escapeIdentifier(p.name)
          << ": "
          << cToNimType(*p.type);
      }
      out << "): ";
      if (m.constructor)
      {
        out
          << c.second.name
          << " {.importcpp: \""
          << c.second.scope + c.second.name
          << "(@)\", header: \""
          << file
          << "\", constructor.}\n";
      }
      else
      {
        out
          << cToNimType(*m.return_type)
          << " {.importcpp, header: \""
          << file
          << "\".}\n";
      }
    }
    out << endl;
  }
}

void print_enums(ostream& out, string& file)
{
  if (enums.empty())
    return;
  out
    << "#\n# Enums\n#\n\n"
    << "type\n";
  for (auto& e: enums)
  {
    out
      << "  "
      << e.second.name
      << "* {.importcpp, header: \""
      << file
      << "\".} = enum\n";
    for (auto& ev: e.second.vals)
    {
      out
        << "    "
        << escapeIdentifier(ev.name);
      if (ev.has_value)
      {
        out
          << " = "
          << ev.value;
      }
      out
        << "\n";
    }
  }
  out << endl;
}

void print_functions(ostream& out, string& file)
{
  if (functions.empty())
    return;
  out << "#\n# Functions\n#\n\n";
  for (auto& f: functions)
  {
    out
      << "proc "
      <<  escapeIdentifier(f.name) << "*(";
    bool first = true;
    for (auto& p: f.params)
    {
      if (!first)
        out << ", ";
      else
        first = false;
      out
        << escapeIdentifier(p.name)
        << ": "
        << cToNimType(*p.type);
    }
    out 
      << "): "
      << cToNimType(*f.return_type)
      << " {.importcpp: \""
      << f.name
      << "(@)\", header: \""
      << file
      << "\".}\n";
  }
  out << endl;
}

void print_typedefs(ostream& out, string& file)
{
  if (typedefs.empty())
    return;
  out
    << "#\n# Typedefs\n#\n\n"
    << "type\n";
  for (auto& t: typedefs)
  {
    out
      << "  "
      << escapeIdentifier(t.second.name)
      << "* ";
    if (knownType(*t.second.ref))
    {
      out
        << "= "
        << cToNimType(*t.second.ref)
        << endl;
    }
    else
    {
      out
        << "{.header: \""
        << file
        << "\", importcpp: \""
        << to_string(*t.second.ref)
        << "\".} = object\n";
    }
  }
  out << endl;
}

void process_entity(const cpp_entity& e)
{
  if (e.kind() == cpp_entity_kind::function_t)
  {
    auto& f = static_cast<const cpp_function&>(e);

    s_function n_fun;
    n_fun.name = f.name();
    n_fun.return_type = &f.return_type();
    for (auto& p: f.parameters())
    {
      if (p.default_value().has_value())
        functions.push_back(n_fun);
      s_variable n_var;
      n_var.name = p.name();
      n_var.type = &p.type();
      n_fun.params.push_back(n_var);
    }
    functions.push_back(n_fun);
  }
  else if (e.kind() == cpp_entity_kind::class_t)
  {
    auto& c = static_cast<const cpp_class&>(e);
    if (classes.find(e.name()) == classes.end() &&
        typedefs.find(e.name()) == typedefs.end() &&
        enums.find(e.name()) == enums.end())
    {
      s_class n_class;
      n_class.name = c.name();
      auto parent = c.parent();
      while (parent.has_value() && parent.value().kind() != cpp_entity_kind::file_t)
      {
        n_class.scope = parent.value().name() + "::" + n_class.scope;
        parent = parent.value().parent();
      }
      n_class.base = c.bases().empty() ? "RootObj" : c.bases().begin()->name();
      classes.emplace(c.name(), n_class);
    }
  }
  else if (e.kind() == cpp_entity_kind::member_function_t)
  {
    auto& m = static_cast<const cpp_member_function&>(e);
    if (m.parent().has_value() && classes.find(m.parent().value().name()) != classes.end())
    {
      s_function n_fun;
      n_fun.name = m.name();
      n_fun.return_type = &m.return_type();
      for (auto& p: m.parameters())
      {
        if (p.default_value().has_value())
          classes[m.parent().value().name()].funs.push_back(n_fun);
        s_variable n_var;
        n_var.name = p.name();
        n_var.type = &p.type();
        n_fun.params.push_back(n_var);
      }
      classes[m.parent().value().name()].funs.push_back(n_fun);
    }
  }
  else if (e.kind() == cpp_entity_kind::constructor_t)
  {
    auto& m = static_cast<const cpp_constructor&>(e);
    if (m.parent().has_value() && classes.find(m.parent().value().name()) != classes.end())
    {
      s_function n_fun;
      n_fun.constructor = true;
      for (auto& p: m.parameters())
      {
        if (p.default_value().has_value())
          classes[m.parent().value().name()].funs.push_back(n_fun);
        s_variable n_var;
        n_var.name = p.name();
        n_var.type = &p.type();
        n_fun.params.push_back(n_var);
      }
      classes[m.parent().value().name()].funs.push_back(n_fun);
    }
  }
  else if (e.kind() == cpp_entity_kind::member_variable_t)
  {
    auto& v = static_cast<const cpp_member_variable&>(e);
    if (v.parent().has_value() && classes.find(v.parent().value().name()) != classes.end())
    {
      s_variable n_var;
      n_var.name = v.name();
      n_var.type = &v.type();
      classes[v.parent().value().name()].vars.push_back(n_var);
    }
  }
  else if (e.kind() == cpp_entity_kind::type_alias_t)
  {
    auto& c = static_cast<const cpp_type_alias&>(e);
    if (classes.find(e.name()) == classes.end() &&
        typedefs.find(e.name()) == typedefs.end() &&
        enums.find(e.name()) == enums.end())
    {
      s_typedef n_typedef;
      n_typedef.name = c.name();
      n_typedef.ref = &c.underlying_type();
      typedefs.emplace(c.name(), n_typedef);
    }
  }
  else if (e.kind() == cpp_entity_kind::enum_t)
  {
    auto& a = static_cast<const cpp_enum&>(e);
    if (classes.find(e.name()) == classes.end() &&
        typedefs.find(e.name()) == typedefs.end() &&
        enums.find(e.name()) == enums.end())
    {
      s_enum n_enum;
      n_enum.name = a.name();
      enums.emplace(a.name(), n_enum);
    }
  }
  else if (e.kind() == cpp_entity_kind::enum_value_t)
  {
    auto& v = static_cast<const cpp_enum_value&>(e);
    if (v.parent().has_value() && enums.find(v.parent().value().name()) != enums.end())
    {
      s_enum_value n_val;
      n_val.name = v.name();
      n_val.has_value = v.value().has_value();
      if (n_val.has_value && v.value().value().kind() == cpp_expression_kind::literal_t)
        n_val.value = static_cast<const cpp_literal_expression&>(v.value().value()).value();
    }
  }
}

void process_ast(const cppast::cpp_file& file, const string& include)
{

  cppast::visit(file, [&](const cppast::cpp_entity& e, cppast::visitor_info info) {
      if (e.kind() == cppast::cpp_entity_kind::file_t || cppast::is_templated(e) || cppast::is_friended(e))
      return true;
      else
      {
      if (info.access == cpp_access_specifier_kind::cpp_public)
      process_entity(e);
      }

      return true;
      });
}

unique_ptr<cppast::cpp_file> parse_file(const cppast::libclang_compile_config& config,
    const cppast::diagnostic_logger&       logger,
    const string& filename, bool fatal_error)
{
  cppast::cpp_entity_index idx;

  cppast::libclang_parser parser(type_safe::ref(logger));

  auto file = parser.parse(idx, filename, config);
  if (fatal_error && parser.error())
    return nullptr;
  return file;
}

int main(int argc, char* argv[])
{
  vector<string> files;
  // the compile config stores compilation flags
  cppast::libclang_compile_config config;
  for (int i = 2; i < argc; i++)
  {
    files.push_back(argv[i]);
  }

  /*
     flags |= cppast::compile_flag::gnu_extensions;
     flags |= cppast::compile_flag::ms_extensions;
     flags |= cppast::compile_flag::ms_compatibility;
     */

  /*
     config.set_flags(cppast::cpp_standard::cpp_98, flags);
     config.set_flags(cppast::cpp_standard::cpp_03, flags);
     config.set_flags(cppast::cpp_standard::cpp_11, flags);
     config.set_flags(cppast::cpp_standard::cpp_14, flags);
     */
  
  //cppast::compile_flags flags;
  //flags |= cppast::compile_flag::gnu_extensions;
  //config.set_flags(cppast::cpp_standard::cpp_1z, flags);

  string moduleName(argv[1]);
  ofstream ofs(moduleName);

  cppast::stderr_diagnostic_logger logger;
  for (string& s: files)
  {
    try
    {
      cout << "Parsing file " << s << endl;
      auto file = parse_file(config, logger, s, false);
      if (!file)
        return 2;

      cout << "Done parsing file." << endl;

      enums.clear();
      classes.clear();
      typedefs.clear();
      functions.clear();

      process_ast(*file, s);

      ofs << "#\n#" << s << "\n#\n\n";

      print_enums(ofs, s);
      print_classes(ofs, s);
      print_typedefs(ofs, s);
      print_functions(ofs, s);

    }
    catch(exception e)
    {
      cerr << "An Error ocurred" << endl;
    }
  }
  ofs.close();

  return 0;
}
